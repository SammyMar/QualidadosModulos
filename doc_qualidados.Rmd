---
title: "Análises dos dados SIVEP-GRIPE, SINASC e SIM para painel Qualidados"
author: 'Qualidados'
date: "`r format(Sys.Date(), '%d/%B/%Y')`"
output:   pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Bases, importações e devidos tratamentos.
 
A seguir são carregados os pacotes do R (https://www.r-project.org) utilizados para filtragem e tratamento dos dados considerados no dashboard https://observatorioobstetrico.shinyapps.io/oobr_qualidados2/. 
 
```{r pacotes, echo=TRUE, message=FALSE, warning =FALSE,error=FALSE, results='hide'}
#carregar pacotes
loadlibrary <- function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = T)
    if (!require(x, character.only = TRUE))
      stop("Package not found")
  }
}

packages <-
  c(
    "readr",
    "readxl",
    "janitor",
    "dplyr",
    "forcats",
    "stringr",
    "lubridate",
    "summarytools",
    "magrittr",
    "questionr",
    "knitr",
    "data.table",
    "writexl",
    "modelsummary",
    'coro',
    'getPass','httr'
  )
lapply(packages, loadlibrary)
```

## SIVEP-GRIPE

A base de dados SIVEP-Gripe (Sistema de Informação da Vigilância Epidemiológica da Gripe) tem os registros dos casos e óbitos de SRAG (Síndrome Respiratória Aguda Grave). A notificação é compulsória para síndrome gripal (caracterizado por pelo menos dois dos seguintes sinais e sintomas: febre, mesmo que referida, calafrios, dor de garganta, dor de cabeça, tosse, coriza, distúrbios olfatórios ou de paladar) e que tem dispneia / desconforto respiratório ou pressão persistente no peito ou Saturação de O2 menor que 95\% no ar ambiente ou cor azulada dos lábios ou rosto. Indivíduos assintomáticos com confirmação laboratorial por biologia molecular ou exame imunológico para infecção por COVID-19 também são relatados.

Para notificações no Sivep-Gripe, os casos hospitalizados em hospitais públicos e privados e todas as mortes devido a infecções respiratórias agudas graves, independentemente da hospitalização, devem ser considerados.

A vigilância da SRAG no Brasil é desenvolvida pelo Ministério da Saúde (MS), por meio da Secretaria de Vigilância em Saúde (SVS), desde a pandemia de Influenza A (H1N1) em 2009. 
Mais informações em https://coronavirus.saude.gov.br/definicao-de-caso-e-notificacao.

### Extração

Os dados de 2009 à 2022 são extraidos com auxílio da API da Plataforma de Ciência de Dados Aplicada à Saúde (PCDaS), sendo previamente tratados com base no fluxo ETL (Extract, Transform e Load). Os dados são filtrados na própria extração da API por meio de consultas SQL como apresentado, onde a váriável `CS_GESTANT` assume os valores: 1-1º Trimestre; 2-2º Trimestre; 3-3º Trimestre; 4-Idade Gestacional Ignorada; 5-Não; 6-Não se aplica; 9-Ignorado.

```{r,echo=FALSE, eval=TRUE, message=FALSE,warning =FALSE,error=FALSE,results='hide'}
memory.limit(9999999)
token <- '4a02c705ba27734cd832080169e29ebb4277d4e0'
```

```{r,echo=TRUE,message=FALSE,warning =FALSE,error=FALSE,results='hide',eval =FALSE}

# Função para converter os resultados das consultas para data.frame
convertRequestToDF <- function(request, column_names = c()){
  if("RequestError" %in% names(content(request))) stop(content(request)$RequestError)
  variables = unlist(content(request)$columns)
  variables = variables[names(variables) == "name"]
  if (!length(column_names)){
    column_names <- unname(variables)
  }
  values = content(request,)$rows
  df <- as.data.frame(do.call(rbind,lapply(values,function(r) {
    row <- r
    row[sapply(row, is.null)] <- NA
    rbind(unlist(row))
  } )))
  names(df) <- column_names
  return(df)
}

query_with_cursor <- generator(function(sql_query, token, nrows){
  tryCatch({
    json_api <- paste0('{"token": {"token": "',token,'"}, "sql": {"sql": {"query":"',sql_query,'", "fetch_size":"',nrows,'" }}}')
    response <- POST(url = "https://bigdata-api.fiocruz.br/sql_query/", body = json_api, encode = "json")
    df <- convertRequestToDF(response)
    col_names <- colnames(df)
    yield(df)
    while(TRUE){
      json_api <- paste0('{"token": {"token": "',token,'"}, "sql": {"sql": {"cursor":"',content(response)$cursor,'" }}}')
      response <- POST(url = "https://bigdata-api.fiocruz.br/sql_query/", body = json_api, encode = "json")
      if(length(content(response)$rows)>0){
        yield(convertRequestToDF(response,col_names))
      }
      else return(NULL)
    }
  }, error=function(cond) message(paste0(cond,"\n",content(response))) )
})

convertColTypeToNum <- function(df, colname){
  df[,colname] <- as.numeric(as.character(df[,colname]))
  return(df)
}

anos <- c(2009:2022)
df_total_max3 <- data.frame()
for(i in anos){
  query <- paste0('SELECT (*)',
                  ' FROM \\"datasus-srags\\" WHERE (',
                  '(CAST(RIGHT(DT_SIN_PRI, 4) AS int) = ',i,') AND ',
                  '(CS_GESTANT = 1 OR CS_GESTANT = 1.0 OR ',
                  'CS_GESTANT = 2 OR CS_GESTANT = 2.0 OR ',
                  'CS_GESTANT = 3 OR CS_GESTANT = 3.0 OR ',
                  'CS_GESTANT = 4 OR CS_GESTANT = 4.0 OR ',
                  'PUERPERA = 1 OR PUERPERA = 1.0))')

  df_total <- data.frame()
  loop(for (df in query_with_cursor(query, token, nrows=10000)) {
    print(paste0('Número de registros recuperados a cada iteração: ', nrow(df)))
    df_total <- rbind(df_total,df)
  })
  df_total_max3 <- rbind(df_total,df_total_max3)

}


write_rds(df_total_max3,file = 'data1/Sivep_2009-2022.rds')
```
Há atualmente `r dim(df_total_max3)[1]` observações na base de dados e são as variáveis:

```{r, echo=TRUE, eval= TRUE, message=FALSE, warning =FALSE, error=FALSE}
names(df_total_max3)
```

```{r, echo=TRUE, eval= TRUE, message=FALSE, warning =FALSE, error=FALSE}
#funções que vamos usar para as medidas descritivas
media <- function(x)
  mean(x, na.rm = TRUE)
mediana <- function(x)
  median(x, na.rm = TRUE)
DP <- function(x)
  sd(x, na.rm = TRUE)
minimo <- function(x)
  base::min(x, na.rm = TRUE)
maximo <- function(x)
  base::max(x, na.rm = TRUE)
q25 <- function(x)
  stats::quantile(x, p = 0.25, na.rm = TRUE)
q75 <- function(x)
  stats::quantile(x, p = 0.75, na.rm = TRUE)
IQR <- function(x)
  round(q75(x) - q25(x), 2)
n <- function(x)
  sum(!is.na(x))
faltantes <- function(x)
  round(sum(is.na(x)), digits = 0)
```

### Tratamento

A base do SIVEP-GRIPE para o Painel qualidados é reorganizada com a substituição dos valores para as determinadas observações que seguirem alguma das regras de indicadores de má qualidade dos dados (Incompletude, Implausibilidade ou Inconsistência). Os indicadores podem ser visualizados na aba de dicionário, na tabela regras, para cada uma das respectivas bases de dados dentro do Painel. Por exemplo, dados `NA`(Not Avaiable) são substituidos por "Em Branco". Tanto os Dicionários de variáveis quanto conjunto de regras estâo disponíveis no github do painel em https://github.com/observatorioobstetrico/Qualidados.

```{r eval=FALSE, echo=TRUE, error=FALSE, message=FALSE, warning=FALSE}
SIVEP_dic <- read_excel("data1/dicionarios.xlsx", sheet = "SIVEP")
df <- readRDS("data1/Sivep_2009-2022.rds")
variaveis_dic <- SIVEP_dic$`Codigo SIVEP`

#BANCO AUXILIAR PARA CORRECAO DOS MUNICIPIOS
aux_muni2 <- abjData::muni %>%
  dplyr::select(uf_id,
                muni_id,
                muni_nm_clean,
                uf_sigla) %>%
  mutate_at("muni_id", as.character)  %>%
  mutate(cod_mun = stringr::str_sub(muni_id, 1, 6))

#CRIANDO CLASSIFICACAO DE GESTANTE E PUERP E CORRIGINDO OS MUNICIPIOS
df_gest <- df %>%
  #CORRECAO MUNICIPIOS
  left_join(aux_muni2, by = c("ID_MUNICIP" = "cod_mun")) %>%
  mutate(SG_UF_NOT = ifelse(is.na(muni_nm_clean), SG_UF_NOT, uf_sigla),
         ID_MUNICIP = ifelse(is.na(muni_nm_clean), ID_MUNICIP, muni_nm_clean)) %>%
  mutate(
    # #CLASSIFICACAO DE PERIODO GESTACIONAL
    # classi_gesta_puerp = case_when(
    #   CS_GESTANT == 1 | CS_GESTANT == 1.0 | CS_GESTANT == '1' | CS_GESTANT == '1.0' ~ "1tri",
    #   CS_GESTANT == 2 | CS_GESTANT == 2.0 | CS_GESTANT == '2' | CS_GESTANT == '2.0' ~ "2tri",
    #   CS_GESTANT == 3 | CS_GESTANT == 3.0 | CS_GESTANT == '3' | CS_GESTANT == '3.0'  ~ "3tri",
    #   CS_GESTANT == 4 | CS_GESTANT == 4.0 | CS_GESTANT == '4' | CS_GESTANT == '4.0' ~ "IG_ig",
    #  ( CS_GESTANT == 5  &
    #     PUERPERA == 1 )| ( CS_GESTANT == 5.0  &
    #                          PUERPERA == 1.0 )| ( CS_GESTANT == '5.0'  &
    #                                                 PUERPERA == '1.0' )~ "puerp",
    #   (CS_GESTANT == 9 & PUERPERA == 1) |(CS_GESTANT == 9.0 & PUERPERA == 1.0)|(CS_GESTANT == '9.0' & PUERPERA == '1.0')~ "puerp",
    #   TRUE ~ "não"
    # ),
    #DATA DO PRIMEIRO SINTOMA
    dt_sint = as.Date(DT_SIN_PRI, format = "%d/%m/%Y"),
    #DATA DO NASCIMENTO
    dt_nasc = as.Date(DT_NASC, format = "%d/%m/%Y"),
    #ANO, BASEADO NA DATA DO PRIMEIRO SINTOMA
    ANO = lubridate::year(dt_sint),
    #MUNICIPIO
    MUNICIPIO = paste(ID_MUNICIP, "-", SG_UF_NOT)
  ) %>% select(-muni_nm_clean, -uf_sigla)
# CORRECAO DO ERRO QUE A FALTA DE PADRONIZACAO DOS DADOS OCASIONOU
df_gest <- df_gest %>% mutate_if(~ !is.character(.), as.character)
df_gest <- data.frame(lapply(df_gest, function(x) ifelse(x == "1.0", '1',
                                                        ifelse(x == '2.0','2',
                                                               ifelse(x == '3.0','3',
                                                                      ifelse(x == '4.0','4',
                                                                             ifelse(x == '5.0','5',
                                                                                    ifelse(x == '6.0','6',
                                                                                           ifelse(x == '7.0','7',
                                                                                                  ifelse(x == '8.0','8',
                                                                                    ifelse(x == '9.0','9',x)))))))))))

df_gest %>% nrow()#CONFERINDO SE VOLTOU TUDO

sivep2 <- df_gest

# INCOMPLETUDE ------------------------------------------------------------
regras_incom <- fromJSON('data1/incompletude_sivep.json')

#VARIAVEIS DO DICIONARIO + VARIAVEIS PARA FILTRAGEM
df_gest2 <- df_gest[,c(variaveis_dic,'ANO','MUNICIPIO','SG_UF_NOT','CLASSI_FIN')]

#VARIAVEIS EM QUE O VALOR 9 E O VALOR IGNORADO:
variaveis_ign <- c('CS_SEXO','CS_RACA','CS_ESCOL_N','CS_ZONA','NOSOCOMIAL','AVE_SUINO','FEBRE','TOSSE','GARGANTA','DISPNEIA',
                   'DESC_RESP','SATURACAO','DIARREIA','VOMITO','OUTRO_SIN','FATOR_RISC','CARDIOPATI','HEMATOLOGI','SIND_DOWN',
                   'HEPATICA','ASMA','DIABETES','NEUROLOGIC','PNEUMOPATI','IMUNODEPRE','RENAL','OBESIDADE','OUT_MORBI',
                   'MAE_VAC','M_AMAMENTA','ANTIVIRAL','HOSPITAL','UTI','SUPORT_VEN','AMOSTRA','POS_PCRFLU','POS_PCROUT',
                   'EVOLUCAO','DOR_ABD','FADIGA','PERD_OLFT','PERD_PALA','POS_AN_FLU','POS_AN_OUT','CS_GESTANT',
                   'TOMO_RES','VACINA_COV','VACINA','PUERPERA','CLASSI_FIN',"RAIOX_RES" )
setdiff(variaveis_dic,variaveis_ign)
#SUBSTITUIR VALORES NA POR EM BRANCO
sivep <- replace(df_gest2,is.na(df_gest2) ,"Em Branco")

#SUBSTITUIR VALORES 9 POR IGNORADO
sivep[, variaveis_ign] <- lapply(sivep[, variaveis_ign], function(x) ifelse((x == '9'|x == '9.0'), "Ignorado", x))

# Calcular as porcentagens de valores 'Ignorados' e 'Em branco' por coluna so para ver se funcionou
 colMeans(sivep == "Ignorado", na.rm = TRUE) * 100
 colMeans(sivep == "Em Branco", na.rm = TRUE) * 100

# IMPLAUSIBILIDADE --------------------------------------------------------

regras_implau <- fromJSON('data1/implausibilidade_gestantes.json')
regras_implau2 <- fromJSON('data1/implausibilidade_puerperas.json')

# Criando vetores de variáveis improváveis e impossíveis
improvavel <- grep("_IMPROVAVEL", names(regras_implau), value = TRUE)
impossivel <- grep("_IMPOSSIVEL", names(regras_implau), value = TRUE)
impossivel2 <- grep("_IMPOSSIVEL", names(regras_implau2), value = TRUE)
impossivel <- c(impossivel2,impossivel) %>% unique()

# Criando um data.frame com as variáveis improváveis
df_improvavel <- data.frame(
  variavel = gsub(improvavel,pattern = '_IMPROVAVEL',replacement = ''))

# Criando um data.frame com as variáveis impossíveis
df_impossivel <- data.frame(
  variavel =  gsub(impossivel,pattern = '_IMPOSSIVEL',replacement = ''))

# Trocando regras em string por booleANOs
df_impossivel <- df_impossivel %>%
  mutate(condicao = case_when(
    grepl("CS_SEXO", variavel) ~ "CS_SEXO != 'F'",
    grepl("NU_IDADE_N", variavel) ~ "as.integer(NU_IDADE_N) < 0 | as.integer(NU_IDADE_N) > 90",
    grepl("CS_GESTANT", variavel) ~ "CS_GESTANT %in% c('1','2','3','4') & PUERPERA == '1' ",
    grepl("DT_INTERNA", variavel) ~ "lubridate::year(as.Date(DT_INTERNA,format = '%d/%m/%Y')) < 2019 & !(is.na(lubridate::year(as.Date(DT_INTERNA,format = '%d/%m/%Y'))))",
    grepl("DT_COLETA", variavel) ~ "lubridate::year(as.Date(DT_COLETA,format = '%d/%m/%Y')) < 2019 & !(is.na(lubridate::year(as.Date(DT_COLETA,format = '%d/%m/%Y'))))",
    grepl("TP_IDADE", variavel) ~ "TP_IDADE != '1' & TP_IDADE != '2' & TP_IDADE != '3'",
    grepl("TP_ANTIVIR", variavel) ~ "TP_ANTIVIR != '1' & TP_ANTIVIR != '2' & TP_ANTIVIR != '3'",
    grepl("SURTO_SG", variavel) ~ "SURTO_SG != '1' & SURTO_SG != '2' & SURTO_SG != 'Ignorado'",
    grepl("NOSOCOMIAL", variavel) ~ "NOSOCOMIAL != '1' & NOSOCOMIAL != '2' & NOSOCOMIAL != 'Ignorado'",
    grepl("AVE_SUINO", variavel) ~ "AVE_SUINO != '1' & AVE_SUINO != '2' & AVE_SUINO != 'Ignorado'",
    grepl("FEBRE", variavel) ~ "FEBRE != '1' & FEBRE != '2' & FEBRE != 'Ignorado'",
    grepl("TOSSE", variavel) ~ "TOSSE != '1' & TOSSE != '2' & TOSSE != 'Ignorado'",
    grepl("GARGANTA", variavel) ~ "GARGANTA != '1' & GARGANTA != '2' & GARGANTA != 'Ignorado'",
    grepl("DISPNEIA", variavel) ~ "DISPNEIA != '1' & DISPNEIA != '2' & DISPNEIA != 'Ignorado'",
    grepl("DESC_RESP", variavel) ~ "DESC_RESP != '1' & DESC_RESP !='2' & DESC_RESP != 'Ignorado'",
    grepl("SATURACAO", variavel) ~ "SATURACAO != '1'  & SATURACAO != '2' & SATURACAO != 'Ignorado'",
    grepl("DIARREIA", variavel) ~ "DIARREIA != '1' & DIARREIA != '2' & DIARREIA != 'Ignorado'",
    grepl("VOMITO", variavel) ~ "VOMITO != '1' & VOMITO != '2' & VOMITO != 'Ignorado'",
    grepl("OUTRO_SIN", variavel) ~ "OUTRO_SIN != '1' & OUTRO_SIN != '2' & OUTRO_SIN != 'Ignorado'",
    grepl("FATOR_RISC", variavel) ~ "FATOR_RISC != '1' & FATOR_RISC != '2' & FATOR_RISC != 'Ignorado'",
    grepl("CARDIOPATI", variavel) ~ "CARDIOPATI != '1' & CARDIOPATI != '2' & CARDIOPATI != 'Ignorado'",
    grepl("HEMATOLOGI", variavel) ~ "HEMATOLOGI != '1' & HEMATOLOGI != '2' & HEMATOLOGI != 'Ignorado'",
    grepl("SIND_DOWN", variavel) ~ "SIND_DOWN != '1' & SIND_DOWN != '2' & SIND_DOWN != 'Ignorado'",
    grepl("HEPATICA", variavel) ~ "HEPATICA != '1' & HEPATICA != '2' & HEPATICA != 'Ignorado'",
    grepl("ASMA", variavel) ~ "ASMA != '1' & ASMA != '2' & ASMA != 'Ignorado'",
    grepl("DIABETES", variavel) ~ "DIABETES != '1' & DIABETES != '2' & DIABETES != 'Ignorado'",
    grepl("NEUROLOGIC", variavel) ~ "NEUROLOGIC != '1' & NEUROLOGIC != '2' & NEUROLOGIC != 'Ignorado'",
    grepl("PNEUMOPATI", variavel) ~ "PNEUMOPATI != '1' & PNEUMOPATI != '2' & PNEUMOPATI != 'Ignorado'",
    grepl("IMUNODEPRE", variavel) ~ "IMUNODEPRE != '1 ' & IMUNODEPRE != '2' & IMUNODEPRE != 'Ignorado'",
    grepl("RENAL", variavel) ~ "RENAL != '1' & RENAL != '2' & RENAL != 'Ignorado'",
    grepl("OBESIDADE", variavel) ~ "OBESIDADE != '1' & OBESIDADE != '2' & OBESIDADE != 'Ignorado'",
    grepl("OUT_MORBI", variavel) ~ "OUT_MORBI != '1' & OUT_MORBI != '2' & OUT_MORBI != 'Ignorado'",
    grepl("VACINA", variavel) ~ "VACINA != '1' & VACINA != '2' & VACINA != 'Ignorado'",
    grepl("MAE_VAC", variavel) ~ "MAE_VAC != '1' & MAE_VAC != '2' & MAE_VAC != 'Ignorado'",
    grepl("M_AMAMENTA", variavel) ~ "M_AMAMENTA != '1' & M_AMAMENTA != '2' & M_AMAMENTA != 'Ignorado'",
    grepl("ANTIVIRAL", variavel) ~ "ANTIVIRAL != '1' & ANTIVIRAL != '2' & ANTIVIRAL != 'Ignorado'",
    grepl("HOSPITAL", variavel) ~ "HOSPITAL != '1' & HOSPITAL != '2' & HOSPITAL != 'Ignorado'",
    grepl("UTI", variavel) ~ "UTI != '1' & UTI != '2' & UTI != 'Ignorado'",
    grepl("AMOSTRA", variavel) ~ "AMOSTRA != '1' & AMOSTRA != '2' & AMOSTRA != 'Ignorado'",
    grepl("POS_PCRFLU", variavel) ~ "POS_PCRFLU != '1' & POS_PCRFLU != '2' & POS_PCRFLU != 'Ignorado'",
    grepl("POS_PCROUT", variavel) ~ "POS_PCROUT != '1' & POS_PCROUT != '2' & POS_PCROUT != 'Ignorado'",
    grepl("HISTO_VGM", variavel) ~ "HISTO_VGM != '1' & HISTO_VGM != '2' & HISTO_VGM != 'Ignorado'",
    grepl("DOR_ABD", variavel) ~ "DOR_ABD != '1' & DOR_ABD != '2' & DOR_ABD != 'Ignorado'",
    grepl("FADIGA", variavel) ~ "FADIGA != '1' & FADIGA != '2' & FADIGA != 'Ignorado'",
    grepl("PERD_OLFT", variavel) ~ "PERD_OLFT != '1' & PERD_OLFT != '2' & PERD_OLFT != 'Ignorado'",
    grepl("PERD_PALA", variavel) ~ "PERD_PALA != '1' & PERD_PALA != '2' & PERD_PALA != 'Ignorado'",
    grepl("POS_AN_FLU", variavel) ~ "POS_AN_FLU != '1' & POS_AN_FLU != '2' & POS_AN_FLU != 'Ignorado'",
    grepl("POS_AN_OUT", variavel) ~ "POS_AN_OUT != '1' & POS_AN_OUT != '2' & POS_AN_OUT != 'Ignorado'",
    grepl("TP_AM_SOR", variavel) ~ "TP_AM_SOR != '1' & TP_AM_SOR != '2' & TP_AM_SOR != 'Ignorado'",
    grepl("PUERPERA", variavel) ~ "(PUERPERA %in% c('1')) & (CS_GESTANT %in% c('1','2','3','4'))"
    ))
    df_improvavel <- df_improvavel %>%
  mutate(condicao = case_when(
    grepl("NU_IDADE_N", variavel) ~ "(as.integer(NU_IDADE_N) < 10 & as.integer(NU_IDADE_N) >= 0) | (as.integer(NU_IDADE_N) > 55 & as.integer(NU_IDADE_N) <= 90)"))

#Substituindo os valores do banco sivep por improvavel e impossivel
attach(sivep)
for(i in 1:nrow(df_impossivel)){
  var <- df_impossivel$variavel[i]
  cond <- df_impossivel$condicao[i]
  sivep[eval(parse(text = paste0(cond," & (",var," != 'Em Branco')"))),var]<- 'Impossivel'
}
for(i in 1:nrow(df_improvavel)){
  var <- df_improvavel$variavel[i]
  cond <- df_improvavel$condicao[i]
  sivep[eval(parse(text = paste0("(",cond,") & (",var," != 'Em branco' &",var," != 'Ignorado') "))),var] <- 'Improvavel'
}
detach(sivep)
sivep_ic_ip <- sivep

# INCONSISTENCIA ----------------------------------------------------------

regras_incon <- fromJSON('data1/SIVEP_Inconsistencias_Regras.json')

# Criando um data.frame com as variáveis improváveis
df_inconsistencia <- data.frame(
  variavel = names(regras_incon) %>% gsub(pattern = '_e_', replacement = ' e '))

# Trocando regras em string por booleANOs
df_inconsistencia <- df_inconsistencia %>%
  mutate(condicao = case_when(
    grepl("CS_SEXO e CS_GESTANT", variavel) ~ "(df_gest_aux$CS_SEXO %in% c('M', 'I')) & (df_gest_aux$CS_GESTANT %in% c('1','2','3','4'))",
    grepl('FATOR_RISC e COMORBIDADES', variavel) ~ "((df_gest_aux$FATOR_RISC == '2' | df_gest_aux$FATOR_RISC == '9') & (df_gest_aux$CARDIOPATI == '1' | df_gest_aux$HEMATOLOGI == '1' | df_gest_aux$SIND_DOWN == '1' | df_gest_aux$HEPATICA == '1' | df_gest_aux$ASMA == '1' | df_gest_aux$DIABETES == '1' |  df_gest_aux$NEUROLOGIC == '1' | df_gest_aux$PNEUMOPATI == '1' | df_gest_aux$IMUNODEPRE == '1' | df_gest_aux$RENAL == '1' | df_gest_aux$OBESIDADE == '1' | df_gest_aux$OBES_IMC == '1' | df_gest_aux$OUT_MORBI == '1')) | ((df_gest_aux$FATOR_RISC == '1') & (df_gest_aux$CARDIOPATI != '1' & df_gest_aux$HEMATOLOGI != '1' & df_gest_aux$SIND_DOWN != '1' & df_gest_aux$HEPATICA != '1' & df_gest_aux$ASMA != '1' & df_gest_aux$DIABETES != '1' &  df_gest_aux$NEUROLOGIC != '1' & df_gest_aux$PNEUMOPATI != '1' & df_gest_aux$IMUNODEPRE != '1' & df_gest_aux$RENAL != '1' & df_gest_aux$OBESIDADE != '1' & df_gest_aux$OBES_IMC != '1' & df_gest_aux$OUT_MORBI != '1'))",
    grepl("VACINA e DT_UT_DOSE", variavel) ~ "df_gest_aux$VACINA %in% c('2', '9') & (df_gest_aux$DT_UT_DOSE != 'Em Branco')",
    grepl("MAE_VAC e DT_VAC_MAE", variavel) ~ "df_gest_aux$MAE_VAC %in% c('2', '9') & (df_gest_aux$DT_VAC_MAE != 'Em Branco')",
    grepl("DT_DOSEUNI e NU_IDADE_N", variavel) ~ "(df_gest_aux$DT_DOSEUNI != 'Em Branco') & (as.integer(df_gest_aux$NU_IDADE_N) <= '6' | as.integer(df_gest_aux$NU_IDADE_N) >= '8')",
    grepl("ANTIVIRAL e TP_ANTIVIR", variavel) ~ "df_gest_aux$ANTIVIRAL %in% c('2', '9') & df_gest_aux$TP_ANTIVIR %in% c('1', '2', '3')",
    grepl("HOSPITAL e DT_INTERNA", variavel) ~ "df_gest_aux$HOSPITAL %in% c('2', '9') & (df_gest_aux$DT_INTERNA != 'Em Branco')",
    grepl("UTI e DT_ENTUTI", variavel) ~ "(df_gest_aux$UTI == '2' | df_gest_aux$UTI == '9') & (df_gest_aux$DT_ENTUTI != 'Em Branco') | (df_gest_aux$HOSPITAL == '2' | df_gest_aux$HOSPITAL == '9') & df_gest_aux$UTI == '1'",
    grepl("RAIOX_RES e DT_RAIOX", variavel) ~ "(df_gest_aux$RAIOX_RES == '6' | df_gest_aux$RAIOX_RES == '9') & (df_gest_aux$DT_RAIOX!= 'Em Branco')",
    grepl("AMOSTRA e DT_COLETA", variavel) ~ "(df_gest_aux$AMOSTRA == '6' | df_gest_aux$AMOSTRA == '9') & (df_gest_aux$DT_COLETA != 'Em Branco')",
    grepl("HISTO_VGM e Campos_VGMs", variavel) ~ "(df_gest_aux$HISTO_VGM == '2' | df_gest_aux$HISTO_VGM == '9') & (df_gest_aux$LO_PS_VGM != 'Em Branco') & (df_gest_aux$DT_VGM != 'Em Branco') & (df_gest_aux$DT_RT_VGM != 'Em Branco')",
    grepl("TOMO_RES e DT_TOMO", variavel) ~ "(df_gest_aux$TOMO_RES == '6' | df_gest_aux$TOMO_RES == '9') & (df_gest_aux$DT_TOMO != 'Em Branco')",
    grepl("TP_TES_AN e DT_RES_AN", variavel) ~ "((df_gest_aux$RES_AN == '4') & (df_gest_aux$TP_TES_AN %in% c('1', '2'))) | ((df_gest_aux$RES_AN == '4') & (df_gest_aux$DT_RES_AN != 'Em Branco'))",
    grepl("VACINA_COV e DOSES", variavel) ~ "(df_gest_aux$VACINA_COV %in% c('2', '9')) & ((df_gest_aux$DOSE_1_COV != 'Em Branco') | (df_gest_aux$DOSE_2_COV!= 'Em Branco'))",
    grepl("CLASSI_FIN_SRAG_INFLUENZA", variavel) ~ "df_gest_aux$CLASSI_FIN == '1' & df_gest_aux$POS_PCRFLU %in% c('2', '9') & df_gest_aux$POS_AN_FLU %in% c('2', '9')",
    grepl("CLASSI_FIN_SRAG_OUTROS_VIRUS", variavel) ~ "df_gest_aux$CLASSI_FIN == '1' & df_gest_aux$PCR_OUTRO %in% c('2', '9') & df_gest_aux$AN_OUTRO %in% c('2 ', '9')"
  ))
df_inconsistencia <- head(df_inconsistencia, -2)

# Criando colunas de inconsistencia no df_gest
df_gest_aux <- df_gest

#SUBSTITUIR VALORES NA POR EM BRANCO
df_gest_aux <- data.frame(lapply(df_gest_aux, function(x) ifelse(is.na(x), "Em Branco", x)))
for(i in 1:nrow(df_inconsistencia)){
  df_gest_aux[[df_inconsistencia$variavel[i]]] <- 'Nao'
}
df_gest_aux %>% colnames() #VENDO SE DEU CERTO

# Verificando a condição de inconsistência para cada variável do Inconsistencias_df

for(i in 1:(nrow(df_inconsistencia))){
  var <- df_inconsistencia$variavel[i]
  cond <- df_inconsistencia$condicao[i]
  df_gest_aux[eval(parse(text = paste0(cond))) ,var] <- 'Inconsistencia'
}
n <- nrow(df_inconsistencia)
maxi <- ncol(df_gest_aux)

# CONCATENANDO E MUDANDO NOME DAS COLUNAS ---------------------------------

sivep <- cbind(sivep_ic_ip,df_gest_aux[,(maxi - n + 1):maxi])

#RENOMEANDO AS COLUNAS COM BASE NO DICIONARIO

nomes_colunas <- colnames(sivep)

# Substituindo os nomes originais pelos novos
for(i in seq_along(SIVEP_dic$`Codigo SIVEP`)) {
  nomes_colunas <- gsub(SIVEP_dic$`Codigo SIVEP`[i],
                        SIVEP_dic$`Codigo Qualidados`[i],
                        nomes_colunas)
}

# Atribuindo os novos nomes de colunas ao dataframe
colnames(sivep) <- nomes_colunas

# CRIAR REGRAS DO SIVEP ---------------------------------------------------
#inconsistencia
regras_incon <- regras_incon |> as.data.frame() |> t() |> as.data.frame()
regras_incon <- cbind(regras_incon |> row.names(),regras_incon)
regras_incon |> row.names() <- NULL
regras_incon |> colnames() <- c('Variavel','Regra')
regras_incon$Variavel <- regras_incon$Variavel |> gsub(pattern = '_e_', replacement = ' e ')
regras_incon$Indicador <- 'Inconsistência'
regras_incon <- regras_incon[-c(17,18),]

#implausibilidade
regras_implau <- regras_implau |> as.data.frame() |> t() |> as.data.frame()
regras_implau <- cbind(regras_implau |> row.names(),regras_implau)
regras_implau |> row.names() <- NULL
regras_implau |> colnames() <- c('Variavel','Regra')
regras_implau$Variavel <- regras_implau$Variavel |> gsub(pattern = '_IMPOSSIVEL', replacement = '')
regras_implau$Regra <- regras_implau$Regra |> gsub(pattern = 'de gestantes ', replacement = '')
regras_implau$Regra <- regras_implau$Regra |> gsub(pattern = 'Gestantes ', replacement = 'Gestantes e puérperas ')
regras_implau$Regra[4] <- 'Gestantes e puérperas ao mesmo tempo'
regras_implau$Indicador <- 'Implausiblidade'

#incompletude
regras_incom <- regras_incom |> as.data.frame() |> t() |> as.data.frame()
regras_incom <- cbind(regras_incom |> row.names(),regras_incom)
regras_incom |> row.names() <- NULL
regras_incom |> colnames() <- c('Variavel','Regra')
regras_incom$Indicador <- 'Incompletude'

#CORRECAO PARA CODIGO DO QUALIDADOS
regras_sivep <- rbind(regras_incon,regras_implau,regras_incom)
for(i in seq_along(SIVEP_dic$`Codigo SIVEP`)) {
  for(j in 1:ncol(regras_sivep)){
  regras_sivep[,j] <- gsub(SIVEP_dic$`Codigo SIVEP`[i],
                           SIVEP_dic$`Codigo Qualidados`[i],
                       regras_sivep[,j])
  }
}

regras_sivep$Variavel <- regras_sivep$Variavel %>% gsub(pattern = '_IMPROVAVEL',replacement = '')

#DESCRICAO DOS INDICADORES
desc_incom <- 'análise das informações que estão faltando na base de dados, seja porque não foram preenchidas (“dados em branco”) ou porque a resposta era desconhecida (“dados ignorados”).'
desc_implau <- "análise das informações que são improváveis e/ou dificilmente possam ser consideradas aceitáveis dadas as características de sua natureza."
desc_incon <- "informações que parecem ilógicas e/ou incompatíveis a partir da análise da combinação dos dados informados em dois ou mais campos do formulário."

var_sivep_incon <- regras_sivep[regras_sivep$Indicador=='Inconsistência','Variavel']
#VARIAVEIS AUXILIARES PARA INCONSISTENCIA
Var_incon_relacao <- list(
  c('SEXO','IDADE_GEST'),
  c('FATOR_RISCO','CARDIOPATI', 'HEMATOLOGI', 'SIND_DOWN', 'HEPÁTICA', 'ASMA', 'DIABETES',
    'NEUROLÓGICA', 'PNEUMOPATIA', 'IMUNODEPRESSAO', 'RENAL_CRON', 'OBESIDADE',
    'OBES_IMC', 'OUT_FATOR_RISCO'),
  c('VACINA','DT_VACINA_GRIPE'),
  c('MAE_VACINA' ,'DT_VACINA_MAE' ),
  c('DT_DOSE_UNICA','IDADE'),
  c('ANTIVIRAL','TIPO_ANTIVIRAL'),
  c('INTERNACAO','DT_INTERNACAO'),
  c('UTI' ,'DT_UTI' ,'INTERNACAO'),
  c('RESULT_RAIOX' ,'DT_RAIOX' ),
  c('AMOSTRA_DIAG' ,'DT_COLETA_AMO' ),
  c('HIST_VIAGEM','LO_PS_VGM', 'DT_VGM', 'DT_RT_VGM'),
  c('RESULT_TOMOGR' ,'DT_TOMOGRAFIA' ),
  c('RES_AN' ,'TIPO_ANTIGENICO' ,'DT_RES_ANTIGENICO' ),
  c('VACINA_COVID' ,'DOSE_1_COV' ,'DOSE_2_COV' ),
  c('CLASSI_FIN' ,'PCR_INFLU' ,'ANTIGENICO_INFLU' ),
  c('CLASSI_FIN' ,'PCR_OUTRO' ,'AN_OUTRO')
)
names(Var_incon_relacao) <- regras_sivep[regras_sivep$Indicador == 'Inconsistência','Variavel']
Var_incon_relacao <- Var_incon_relacao[var_sivep_incon] %>% unlist() %>% unname()
Var_incon_relacao <- Var_incon_relacao[Var_incon_relacao %in% colnames(sivep)]

#VARIAVEIS PARA FILTRO
var_sivep_implau <- regras_sivep$Variavel[regras_sivep$Indicador == 'Implausiblidade'] %>% unique()
var_sivep_incom <- regras_sivep$Variavel[regras_sivep$Indicador == 'Incompletude'] %>% unique()

#DADOS
usethis::use_data(sivep,overwrite = T)
#VARIVEIS PARA FILTRO
usethis::use_data(Var_incon_relacao,overwrite = T)
usethis::use_data(var_sivep_incom,overwrite = T)
usethis::use_data(var_sivep_implau,overwrite = T)
usethis::use_data(var_sivep_incon,overwrite = T)
#DESCRICAO
usethis::use_data(desc_incom, overwrite = T)
usethis::use_data(desc_implau, overwrite = T)
usethis::use_data(desc_incon, overwrite = T)
#DICIONARIO
usethis::use_data(SIVEP_dic,overwrite = T)
usethis::use_data(regras_sivep,overwrite = T)
```

### Análise dos dados

#### Gestante ou Puérpera





## SINASC

O Sistema de Informações sobre Nascidos Vivos (SINASC) foi implantado oficialmente a partir de 1990, com o objetivo de coletar dados sobre os nascimentos ocorridos em todo o território nacional e fornecer informações sobre natalidade para todos os níveis do Sistema de Saúde.

### Extração e Tratamento

Bem como para a base de dados do SIVEP-GRIPE os dados para o SINASC, e como vai ser visto para o SIM também, a extração dos dados foi realizada por meio de API proporcionada pela PCDas para os anos de 1996 à 2020. Ainda na extração pela API os dados são devidamente filtrados, tratados e subdivididos em três bases devido ao tamanho excessivo do arquivo completo, onde cada uma das três bases corresponde a um dos indicadores trabalhados nos painéis. As bases finais apresentam apenas o núemro de casos dos indicadores e número total de observações agrupados por: Município-UF, Ano e variável.

```{python eval=FALSE}
# INCOMPLETUDE  #################################

import glob
import pandas as pd
from collections import Counter
import datetime as dt

import warnings
warnings.filterwarnings("ignore")

regras_ignorados = {}
regras_ignorados['LOCNASC'] = [9]
regras_ignorados['ESTCIVMAE'] = [9]
regras_ignorados['ESCMAE'] = [9]
regras_ignorados['GESTACAO'] = [9]
regras_ignorados['GRAVIDEZ'] = [9]
regras_ignorados['PARTO'] = [9]
regras_ignorados['CONSULTAS'] = [9]
regras_ignorados['CONSULTAS'] = [9]
regras_ignorados['SEXO'] = [0, 9, 'I']
regras_ignorados['RACACOR'] = [9]
regras_ignorados['IDANOMAL'] = [8,9]
regras_ignorados['ESCMAE2010'] = [9]
regras_ignorados['TPMETESTIM'] = [8,9]
regras_ignorados['TPMETESTIM'] = [99]
regras_ignorados['TPAPRESENT'] = [9]
regras_ignorados['STTRABPART'] = [9]
regras_ignorados['STCESPARTO'] = [9]
regras_ignorados['TPNASCASSI'] = [9]
regras_ignorados['TPFUNCRESP'] = [0]
regras_ignorados['ESCMAEAGR1'] = [9]
regras_ignorados['TPROBSON'] = [11,12]
regras_ignorados['IDADEMAE'] = [99]
regras_ignorados['PESO'] = [9999]



for f in glob.glob('SINASC_dataset/*.csv'):
    
    df = pd.read_csv(f)
    print(len(df))
    ano = f.split('/')[1].split('_')[3].split('.')[0]
    codmun = df['CODMUNNASC']
    estado = f.split('/')[1].split('_')[2]
        
    df_ignorados = df.copy()
    df_totais = df.isna()
    df_nulos = df_totais.copy()
        
    df_totais['ANO'] = ano
    df_totais['CODMUNNASC'] = codmun

    df_totais = df_totais.groupby(['ANO','CODMUNNASC']).count().reset_index().melt(id_vars=['ANO','CODMUNNASC'])
    
    df_totais.columns = ['ANO','CODMUNNASC','VARIAVEL','TOTAIS']

    df_nulos['CODMUNNASC'] = codmun
    df_nulos['ANO'] = ano
    
    df_nulos = df_nulos.groupby(['ANO','CODMUNNASC']).sum().reset_index().melt(id_vars=['ANO','CODMUNNASC'])
    df_nulos.columns = ['ANO','CODMUNNASC','VARIAVEL','NULOS']
    
    for c in df_ignorados.columns:
        if c in regras_ignorados:
            df_ignorados[c] = df_ignorados[c].isin(regras_ignorados[c])
        else:
            if c not in ['ANO','CODMUNNASC']:
                df_ignorados.drop(columns=[c], inplace=True)
    
    df_ignorados['CODMUNNASC'] = codmun
    df_ignorados['ANO'] = ano

    df_ignorados = df_ignorados.groupby(['ANO','CODMUNNASC']).sum().reset_index().melt(id_vars=['ANO','CODMUNNASC'])
    df_ignorados.columns = ['ANO','CODMUNNASC','VARIAVEL','IGNORADOS']
    
    df_ignorados = df_ignorados.fillna(0)

    x = df_totais.merge(df_nulos, how='left', on=['ANO','CODMUNNASC','VARIAVEL'])
    x = x.merge(df_ignorados, how='left', on=['ANO','CODMUNNASC','VARIAVEL'])
    x = x.reset_index()
    
    x = x[['ANO','CODMUNNASC','VARIAVEL','NULOS','IGNORADOS','TOTAIS']]
    
    x = x.fillna(0)  
    
    x.to_csv('SINASC_dataset/resultados/Incompletude_{}_{}.csv'.format(estado, ano),
             index=None, compression='gzip')
             
incompletude = pd.DataFrame()

for f in glob.glob('SINASC_dataset/resultados/Incompletude_*.csv'):
    df = pd.read_csv(f, compression='gzip')
    incompletude = pd.concat([incompletude, df], axis=0)

incompletude.fillna(0, inplace=True)
incompletude = incompletude[~incompletude.VARIAVEL.isin(['contador','NOVO'])]
incompletude.to_csv('SINASC_Incompletude_v2.csv', index=None, compression='gzip')

# gera regras

import json

regras = {}
for r in regras_ignorados:
    regras["IGNORADOS_" + r] = "Se o campo " + r + " estiver preenchido com " + str(regras_ignorados[r])
    
with open('SINASC_Incompletude_Regras.json', 'w') as fp:
    json.dump(regras, fp,  indent=4)
    
#IMPLAUSIBLIDADE

colunas_implausibilidade = ['ANO','ESTADO','CODMUNNASC','LOCNASC',
                            'IDADEMAE','ESTCIVMAE','ESCMAE','QTDFILVIVO',
                            'QTDFILMORT','GESTACAO','GRAVIDEZ','PARTO',
                            'CONSULTAS','DTNASC','HORANASC','SEXO',
                            'APGAR1','APGAR5','RACACOR','PESO','IDANOMAL',
                            'DTCADASTRO','CODANOMAL','ESCMAE2010','DTNASCMAE',
                            'QTDGESTANT','QTDPARTNOR','QTDPARTCES','IDADEPAI',
                            'DTULTMENST','SEMAGESTAC','TPMETESTIM','TPAPRESENT',
                            'STTRABPART','STCESPARTO','TPNASCASSI','TPFUNCRESP',
                            'TPDOCRESP','TPROBSON','SERIESCMAE','CONSPRENAT',
                            'MESPRENAT','ESCMAEAGR1','PARIDADE']

# aplica as regras para variaveis com opcoes
regras_gerais = { 'LOCNASC':[1,2,3,4,5,9],
                  'ESTCIVMAE':[1,2,3,4,5,9],
                  'ESCMAE':[1,2,3,4,5,9],
                  'GESTACAO':[1,2,3,4,5,6,9],
                  'GRAVIDEZ':[1,2,3,9],
                  'PARTO':[1,2,9],
                  'CONSULTAS':[1,2,3,4,9],
                  'SEXO':[1,2,9,0,'M','F','I'],
                  'RACACOR':[1,2,3,4,5],
                  'IDANOMAL':[1,2,9],
                  'ESCMAE2010':[1,2,3,4,5,9],
                  'TPMETESTIM':[1,2,9],
                  'TPAPRESENT':[1,2,3,9],
                  'STTRABPART':[1,2,3,9],
                  'STCESPARTO':[1,2,3,9],
                  'TPNASCASSI':[1,2,3,4,9],
                  'TPFUNCRESP':[1,2,3,4,5,9],
                  'TPDOCRESP':[1,2,3,4,5],
                  'TPROBSON': list(range(1,13)), # 1 a 12
                  'SERIESCMAE': list(range(1,9)), # 1 a 8
                  'MESPRENAT': list(range(1,11)) + [99], # 1 a 10 e 99
                  'ESCMAEAGR1': list(range(1,13)), # 1 a 12,
                }

# incompletude ###################################################
for f in glob.glob('SINASC_dataset/*.csv'):
    
    df = pd.read_csv(f)
    ano = f.split('/')[1].split('_')[3].split('.')[0]
    estado = f.split('/')[1].split('_')[2]
    codmun = df['CODMUNNASC']
        
    aux_cols = []
    for c in colunas_implausibilidade:
        if c in df.columns:
            aux_cols.append(c)
    
    aux = df[aux_cols]
    
    aux['ANO'] = ano
    aux['CODMUNNASC'] = codmun
    
    print(ano, estado)
    
    for col in regras_gerais.keys():
        if col in aux_cols:
            aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & (~aux[col].isin(regras_gerais[col]))
        
    # REGRAS ESPECÍFICAS
    
    col = 'IDADEMAE'
    if col in aux_cols:
        aux[col] = pd.to_numeric(aux[col], errors='coerce')

        aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & ((aux[col] < 10) | (aux[col] > 55))
    
    for col in ['QTDFILVIVO','QTDFILMORT']:
        if col not in aux_cols:
            continue
        aux[col] = pd.to_numeric(aux[col], errors='coerce')
        aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & ((aux[col] < 0) | (aux[col] > 70))
        
    col = 'PESO'
    if col in aux_cols:
        aux[col] = pd.to_numeric(aux[col], errors='coerce')
        aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & ((aux[col] < 0) | (aux[col] > 11000))

    for col in ['QTDGESTANT','QTDPARTNOR','QTDPARTCES']:
        if col not in aux_cols:
            continue
        aux[col] = pd.to_numeric(aux[col], errors='coerce')
        aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & ((aux[col] < 0) | (aux[col] > 27))

    col = 'IDADEPAI'
    if col in aux_cols:
        aux[col] = pd.to_numeric(aux[col], errors='coerce')
        aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & ((aux[col] < 10) | (aux[col] > 99))

    col = 'SEMAGESTAC'
    if col in aux_cols:
        aux[col] = pd.to_numeric(aux[col], errors='coerce')
        aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & (aux[col] < 20)
        
    col = 'CONSPRENAT'
    if col in aux_cols:
        aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & (aux[col] < 0)
        
    for col in ['DTNASC','DTCADASTRO']:
        if col in aux_cols:
            aux[col] = pd.to_numeric(df[col].astype(str).str[-4:], errors='coerce')
            aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & (aux[col] > dt.date.today().year)
      
    col = 'DTNASCMAE'
    if col in aux_cols:
        aux[col] = pd.to_numeric(df[col].astype(str).str[-4:], errors='coerce')
        aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & ((aux[col] > 2012) | (aux[col] < 1967))
        
    col = 'HORANASC'
    if col in aux_cols:
        if df[col].dtype == "object":
            df[col] = df[col].str.replace(";","")
            df[col] = pd.to_numeric(df[col], errors='coerce')
        hora = pd.to_numeric(df[col], errors='coerce') // 100
        minuto = pd.to_numeric(df[col], errors='coerce') % 100
        aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & (df[col] > 59) & (hora > 23) & (minuto > 59) # 00:59 vira 59 só
        
    for col in ['APGAR1','APGAR5']:
        if col in aux_cols:
            aux[col] = pd.to_numeric(aux[col], errors='coerce')
            aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & ((aux[col] < 0) | (aux[col] > 10))
        
    col = 'PARIDADE'
    if col in aux_cols:
        aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & ((aux[col] < 0) | (aux[col] > 27))
    
    aux_cols = []
    
    for c in aux.columns:
        if 'IMPLAUSIVEL' in c:
            aux_cols.append(c)
            
    aux_cols = ['ANO','ESTADO','CODMUNNASC'] + aux_cols
    
    df_implausiveis = aux[aux_cols]
    
    df_implausiveis.fillna(0, inplace=True)
    
    df_implausiveis = df_implausiveis.groupby(['ANO','CODMUNNASC']).sum().reset_index().melt(id_vars=['ANO','CODMUNNASC'])
    df_implausiveis.columns = ['ANO','CODMUNNASC','VARIAVEL','IMPLAUSIVEIS']    

    
    df['ANO'] = ano
    df['CODMUNNASC'] = codmun
    
    df_totais = df[['ANO','CODMUNNASC']]
    df_totais['TOTAIS'] = 1

    df_totais = df_totais.groupby(['ANO','CODMUNNASC'])['TOTAIS'].sum().reset_index()
    df_totais.columns = ['ANO','CODMUNNASC','TOTAIS']
        
    df_totais.set_index(['ANO','CODMUNNASC'], inplace=True)
    df_implausiveis.set_index(['ANO','CODMUNNASC'], inplace=True)
        
    x = df_totais.join([df_implausiveis], how='left')
    x = x.reset_index()
    
    x = x[['ANO','CODMUNNASC','VARIAVEL','IMPLAUSIVEIS','TOTAIS']]
    
    x = x.fillna(0)  
    
    x.to_csv('SINASC_dataset/resultados/Implausiiblidade_{}_{}.csv'.format(estado, ano),
             index=None, compression='gzip')
implausibilidade = pd.DataFrame()

for f in glob.glob('SINASC_dataset/resultados/Implausiiblidade_*.csv'):
    df = pd.read_csv(f, compression='gzip')
    implausibilidade = pd.concat([implausibilidade, df], axis=0)

implausibilidade.fillna(0, inplace=True)
implausibilidade.to_csv('SINASC_Implausibilidade_v2.csv', index=None, compression='gzip')

# gera regras

import json

regras = {}
regras["IDADEMAE"] = "Se campo IDADEMAE for menor que 10 ou maior que 55"
regras["QTDFILVIVO"] = "Se campo QTDFILVIVO for menor que 0 ou maior que 70"
regras["QTDFILMORT"] = "Se campo QTDFILMORT for menor que 0 ou maior que 70"
regras["PESO"] = "Se campo PESO for menor que 0 ou maior que 11000"
regras["QTDGESTANT"] = "Se campo QTDGESTANT for menor que 0 ou maior que 27"
regras["QTDPARTNOR"] = "Se campo QTDPARTNOR for menor que 0 ou maior que 27"
regras["QTDPARTCES"] = "Se campo QTDPARTCES for menor que 0 ou maior que 27"
regras["IDADEPAI"] = "Se campo IDADEPAI for menor que 10 ou maior que 99"
regras["SEMAGESTAC"] = "Se campo SEMAGESTAC for menor que 20"
regras["CONSPRENAT"] = "Se campo SEMAGESTAC for menor que 0"
regras["DTNASC"] = "Se campo DTNASC for maior que a data da última atualização dos dados"
regras["DTCADASTRO"] = "Se campo DTCADASTRO for menor que a data da última atualização dos dados"
regras["DTNASCMAE"] = "Se campo DTNASCMAE for menor que 1967 ou maior que 2012"
regras["HORANASC"] = "Se campo HORANASC não for uma hora válida"
regras["APGAR1"] = "Se campo APGAR1 for menor que 0 ou maior que 10"
regras["APGAR5"] = "Se campo APGAR5 for menor que 0 ou maior que 10"
regras["PARIDADE"] = "Se campo APGAR5 for menor que 0 ou maior que 27"

for k in regras_gerais.keys():
    if k not in regras.keys():
        regras[k] = "Se o campo " + k + "não for preenchido com " + str(regras_gerais[k])
    
with open('SINASC_Implausibilidade_Regras.json', 'w') as fp:
    json.dump(regras, fp,  indent=4)
    
#INCONSISTENCIA ###########################################################################


regras = {}
regras['LOCNASC_e_PARTO'] = "Se campo LOCNASC for 2,3,4,5 e o campo PARTO estiver preenchido com 2"
regras['PARTO_e_STCESPARTO'] = "Se o campo STCESPARTO estiver preenchido como 1 e o campo PARTO estiver como 2 ou 9"
regras['TPROBSON_e_composicao'] = "Se o campo TPROBSON estiver preenchido entre 1 e 10 e qualquer um dos campos QTDGESTANT,QTDPARTNOR,QTDPARTCES,SEMAGESTAC,TPAPRESENT,STTRABPART estiverem em branco"                                          
#regras['PARTO_PREMATURO_e_GESTACAO'] = "Se o campo PARTO_PREMATURO estiver preenchido como 1 e o campo GESTACAO estiver como 5 ou 6"
#regras['PARTO_PREMATURO_e_PESO'] = "Se o campo PARTO_PREMATURO estiver preenchido como 1 e o campo PESO > 2500"
#regras['PARTO_PREMATURO_PESO_e_GESTACAO'] = "Combinação das regras de parto prematuro, gestação e peso inconsistentes"
#regras['PARTO_PREMATURO_e_GESTACAO_2'] = "Se o campo PARTO_PREMATURO estiver preenchido como 0 e o campo PESO estiver preenchido como 1, 2, 3 ou 4"

# inconsistencia
for f in glob.glob('SINASC_dataset/*.csv'):
    
    df = pd.read_csv(f)
    
    ano = f.split('/')[1].split('_')[3].split('.')[0]
    estado = f.split('/')[1].split('_')[2]
    codmun = df['CODMUNNASC']
    
    df['PESO'] = df['PESO'].apply(pd.to_numeric, errors='coerce')
    
    df['parto_prematuro'] = df['GESTACAO'] <= 4
    
    aux_cols = []

    base = df

    # LOCNASC e PARTO
    base['LOCNASC_e_PARTO_INCONSISTENTES'] = (base['LOCNASC'].isin([2,3,4,5])) & (base['PARTO'] == 2)

    # PARTO e STCESPARTO
    if 'STCESPARTO' in base.columns:
        base['PARTO_e_STCESPARTO_INCONSISTENTES'] = (base['STCESPARTO'] == 1) & (base['PARTO'].isin([2,9]))

    # TPROBSON e composicao
    if 'TPROBSON' in base.columns:
        base['TPROBSON_e_composicao_INCONSISTENTES'] = (base['TPROBSON'].isin([1,2,3,4,5,6,7,8,9,10])) & ((~base[['QTDGESTANT','QTDPARTNOR','QTDPARTCES','SEMAGESTAC','TPAPRESENT','STTRABPART']].isna()).sum(axis = 1) > 0)

    # PARTO_PREMATURO e PESO
    base['PARTO_PREMATURO_e_PESO_INCONSISTENTES'] = (base['parto_prematuro'] == 1) & (base['PESO'] > 2500)

    aux_cols = []
    for c in base.columns:
        if 'INCONSISTENTES' in c:
            aux_cols.append(c)
            
    aux = base[aux_cols]
    
    aux['ANO'] = ano
    aux['CODMUNNASC'] = codmun

    df_inconsistentes = aux
    
    df_inconsistentes.fillna(0, inplace=True)
    
    df_inconsistentes = df_inconsistentes.groupby(['ANO','CODMUNNASC']).sum().reset_index().melt(id_vars=['ANO','CODMUNNASC'])
    df_inconsistentes.columns = ['ANO','CODMUNNASC','VARIAVEL','INCONSISTENTES']
    
    df['ANO'] = ano
    df['CODMUNNASC'] = codmun
    
    df_totais = df[['ANO','CODMUNNASC']]
    df_totais['TOTAIS'] = 1

    df_totais = df_totais.groupby(['ANO','CODMUNNASC'])['TOTAIS'].sum().reset_index()
    df_totais.columns = ['ANO','CODMUNNASC','TOTAIS']
        
    df_totais.set_index(['ANO','CODMUNNASC'], inplace=True)
    df_inconsistentes.set_index(['ANO','CODMUNNASC'], inplace=True)
        
    x = df_totais.join([df_inconsistentes], how='left')
    x = x.reset_index()
    
    x = x[['ANO','CODMUNNASC','VARIAVEL','INCONSISTENTES','TOTAIS']]
    
    x = x.fillna(0)  
    
    x.to_csv('SINASC_dataset/resultados/Inconsistencia_{}_{}.csv'.format(estado, ano),
             index=None, compression='gzip')

inconsistencias = pd.DataFrame()

for f in glob.glob('SINASC_dataset/resultados/Inconsistencia_*.csv'):
    df = pd.read_csv(f, compression='gzip')
    inconsistencias = pd.concat([inconsistencias, df], axis=0)

inconsistencias.fillna(0, inplace=True)
inconsistencias.to_csv('SINASC_Inconsistencia_v2.csv', index=None, compression='gzip')

# gera regras

import json
    
with open('SINASC_Inconsistencias_Regras.json', 'w') as fp:
    json.dump(regras, fp,  indent=4)

```

### Análise

## SIM

O Sistema de Informação Sobre Mortalidade (SIM), desenvolvido pelo Ministério da Saúde, em 1975, é produto da unificação de mais de quarenta modelos de instrumentos utilizados, ao longo dos anos, para coletar dados sobre mortalidade no país. Possui variáveis que permitem, a partir da causa mortis atestada pelo médico, construir indicadores e processar análises epidemiológicas que contribuam para a eficiência da gestão em saúde.

O SIM foi informatizado em 1979. Doze anos depois, com a implantação do SUS e sob a premissa da descentralização teve a coleta de dados repassada à atribuição dos Estados e Municípios, através das suas respectivas Secretarias de Saúde. Com a finalidade de reunir dados quantitativos e qualitativos sobre óbitos ocorridos no Brasil, o SIM é considerado uma importante ferramenta de gestão na área da saúde que subsidiam a tomada de decisão em diversas áreas da assistência à saúde. No nível federal, sua gestão está afeta à Secretaria de Vigilância à Saúde.

### Extração e Tratamento

A extração dos dados foi realizada por meio da API da PCDas para os anos de 1996 à 2020 com apoio de linguagem Python, onde os dados sâo tratados ainda no processo de extração e, como realizado para a base de dados do SINASC, é feito a subdivisão para cada um dos indicadores trabalhados com objetivo de reduzir o tamanho das bases. As bases finais apresentam apenas o núemro de casos dos indicadores e número total de observações agrupados por: Município-UF, Ano e variável.

```{python eval=FALSE}
## INCOMPLETUDE
regras_ignorados = {}
regras_ignorados['TIPOBITO'] = ['NA']
regras_ignorados['SEXO'] = ['I','0']
regras_ignorados['RACACOR'] = ['NA']
regras_ignorados['ESTCIV'] = [9]
regras_ignorados['ESC'] = [9]
regras_ignorados['ESCMAE'] = [9]
regras_ignorados['QTDFILVIVO'] = [99]
regras_ignorados['QTDFILMORT'] = [99]
regras_ignorados['GRAVIDEZ'] = [9]
regras_ignorados['GESTACAO'] = [9]
regras_ignorados['PARTO'] = [8,9]
regras_ignorados['OBITOPARTO'] = [9]
regras_ignorados['OBITOGRAV'] = [8,9]
regras_ignorados['OBITOPUERP'] = [99]
regras_ignorados['ASSISTMED'] = [9]
regras_ignorados['EXAME'] = [9]
regras_ignorados['CIRURGIA'] = [9]
regras_ignorados['NECROPSIA'] = [9]
regras_ignorados['CIRCOBITO'] = [0]
regras_ignorados['ACIDTRAB'] = [9]
regras_ignorados['FONTE'] = [9]
regras_ignorados['TPMORTEOCO'] = [9]
regras_ignorados['FONTEINV'] = [9]
regras_ignorados['ESCMAEAGR1'] = [9]
regras_ignorados['ESCFALAGR1'] = [9]

# incompletude
cont = 0
for f in glob.glob('SIM_dataset/*.csv'):
    
    df = pd.read_csv(f)
    ano = df['DTOBITO'] % 10000
    codmun = df['CODMUNOCOR']
        
    df_ignorados = df.copy()
    df_totais = df.isna()
    
    df_totais = df.isna()
    df_nulos = df_totais.copy()
    
    df_totais[df_totais == True] = 1
    df_totais[df_totais == False] = 1
    
    df_totais['ANO'] = ano
    df_totais['CODMUNOCOR'] = codmun

    df_totais = df_totais.groupby(['ANO','CODMUNOCOR']).count().reset_index().melt(id_vars=['ANO','CODMUNOCOR'])
    df_totais.columns = ['ANO','CODMUNOCOR','VARIAVEL','TOTAIS']
        
    df_nulos['CODMUNNASC'] = codmun
    df_nulos['ANO'] = ano
    
    df_nulos = df_nulos.groupby(['ANO','CODMUNOCOR']).sum().reset_index().melt(id_vars=['ANO','CODMUNOCOR'])
    df_nulos.columns = ['ANO','CODMUNOCOR','VARIAVEL','NULOS']
    
    for c in df_ignorados.columns:
        if c in regras_ignorados:
            df_ignorados[c] = df_ignorados[c].isin(regras_ignorados[c])
        else:
            if c not in ['ANO','CODMUNOCOR']:
                df_ignorados.drop(columns=[c], inplace=True)
    
    df_ignorados['CODMUNOCOR'] = codmun
    df_ignorados['ANO'] = ano

    df_ignorados = df_ignorados.groupby(['ANO','CODMUNOCOR']).sum().reset_index().melt(id_vars=['ANO','CODMUNOCOR'])
    df_ignorados.columns = ['ANO','CODMUNOCOR','VARIAVEL','IGNORADOS']
    
    df_ignorados = df_ignorados.fillna(0)
    
    df_totais.set_index(['ANO','CODMUNOCOR','VARIAVEL'], inplace=True)
    df_nulos.set_index(['ANO','CODMUNOCOR','VARIAVEL'], inplace=True)
    df_ignorados.set_index(['ANO','CODMUNOCOR','VARIAVEL'], inplace=True)
        
    x = df_totais.join([df_nulos, df_ignorados], how='left')
    x = x.reset_index()
    
    x = x[['ANO','CODMUNOCOR','VARIAVEL','NULOS','IGNORADOS','TOTAIS']]
    
    x = x.fillna(0)  
    
    x.to_csv('SIM_dataset/resultados/Incompletude_p{}.csv'.format(cont),
             index=None, compression='gzip')
    
    cont += 1

incompletude = pd.DataFrame()

for f in glob.glob('SIM_dataset/resultados/Incompletude_p*.csv'):
    df = pd.read_csv(f, compression='gzip')
    incompletude = pd.concat([incompletude, df], axis=0)

incompletude.fillna(0, inplace=True)
incompletude = incompletude[~incompletude.VARIAVEL.isin(['contador','NOVO'])]
incompletude.to_csv('SIM_Incompletude_v2.csv', index=None, compression='gzip')

# gera regras

regras = {}
for r in regras_ignorados:
    regras["IGNORADOS_" + r] = "Se o campo " + r + "estiver preenchido com " + str(regras_ignorados[r])
    
with open('SIM_Incompletude_Regras.json', 'w') as fp:
    json.dump(regras, fp,  indent=4)
    
### implausiblidade ###############################################################
# aplica as regras para variaveis com opcoes
regras_gerais = {'TIPOBITO':[1,2],
                 'SEXO':[1,2,9,0,'M','F','I'],
                 'RACACOR':[1,2,3,4,5],
                 'ESTCIV':[1,2,3,4,5,9],
                 'ESC':[1,2,3,4,5,9],
                 'LOCOCOR':[1,2,3,4,5,9],
                 'ESCMAE':[1,2,3,4,5,9],
                 'GRAVIDEZ':[1,2,3,9],
                 'GESTACAO':[1,2,3,4,5,6,9],
                 'PARTO':[1,2,9],
                 'OBITOPARTO':[1,2,3,9],
                 'OBITOGRAV':[1,2,9],
                 'OBITOPUERP':[1,2,3,9],
                 'ASSISTMED':[1,2,3,9],
                 'EXAME':[1,2,3,9],
                 'CIRURGIA':[1,2,3,9],
                 'NECROPSIA':[1,2,3,9],
                 'CIRCOBITO':[1,2,3,4,9],
                 'ACIDTRAB':[1,2,9],
                 'FONTE':[1,2,3,4,9],
                 'SERIESCMAE': list(range(1,9)),
                 'TPMORTEOCO':[1,2,3,4,5,8,9],
                 'TPPOS':[1,2],
                 'ATESTANTE': list(range(1,6)),
                 'FONTEINV': [1,2,3,4,6,7,8,9],
                 'ESCMAEAGR1': list(range(1,13)),
                 'ESCFALAGR1': list(range(1,13)),
                }

colunas_implausibilidade = regras_gerais.keys()

cont = 0
# implausibilidade
for f in glob.glob('SIM_dataset/*.csv'):
    
    df = pd.read_csv(f)
    ano = df['DTOBITO'] % 10000
    codmun = df['CODMUNOCOR']
    
    aux_cols = []
    for c in colunas_implausibilidade:
        if c in df.columns:
            aux_cols.append(c)
    
    aux = df[aux_cols]
    
    aux['ANO'] = ano
    aux['CODMUNOCOR'] = codmun
    
    for col in regras_gerais.keys():
        if col in aux_cols:
            aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & (~aux[col].isin(regras_gerais[col]))
        
    # REGRAS ESPECÍFICAS
    
    for col in ['IDADE','IDADEMAE']:
        if col not in aux_cols:
            continue
        aux[col] = pd.to_numeric(aux[col], errors='coerce')
        aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & ((aux[col] < 0) | (aux[col] > 120))
    
    for col in ['QTDFILVIVO','QTDFILMORT']:
        if col not in aux_cols:
            continue
        aux[col] = pd.to_numeric(aux[col], errors='coerce')
        aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & (aux[col] != 99) & ((aux[col] < 0) | (aux[col] > 70))
        
    col = 'PESO'
    if col in aux_cols:
        aux[col] = pd.to_numeric(aux[col], errors='coerce')
        aux[col + "_IMPLAUSIVEL"] = (~aux[col].isna()) & ((aux[col] < 0) | (aux[col] > 11000))

    aux_cols = []
    
    for c in aux.columns:
        if 'IMPLAUSIVEL' in c:
            aux_cols.append(c)
            
    aux_cols = ['ANO','CODMUNOCOR'] + aux_cols
    
    df_implausiveis = aux[aux_cols]
    
    df_implausiveis.fillna(0, inplace=True)
    
    df_implausiveis = df_implausiveis.groupby(['ANO','CODMUNOCOR']).sum().reset_index().melt(id_vars=['ANO','CODMUNOCOR'])
    df_implausiveis.columns = ['ANO','CODMUNOCOR','VARIAVEL','IMPLAUSIVEIS']    

    
    df['ANO'] = ano
    df['CODMUNOCOR'] = codmun
    
    df_totais = df[['ANO','CODMUNOCOR']]
    df_totais['TOTAIS'] = 1

    df_totais = df_totais.groupby(['ANO','CODMUNOCOR'])['TOTAIS'].sum().reset_index()
    df_totais.columns = ['ANO','CODMUNOCOR','TOTAIS']
        
    df_totais.set_index(['ANO','CODMUNOCOR'], inplace=True)
    df_implausiveis.set_index(['ANO','CODMUNOCOR'], inplace=True)
        
    x = df_totais.join([df_implausiveis], how='left')
    x = x.reset_index()
    
    x = x[['ANO','CODMUNOCOR','VARIAVEL','IMPLAUSIVEIS','TOTAIS']]
    
    x = x.fillna(0)  
    
    x.to_csv('SIM_dataset/resultados/Implausibilidade_p{}.csv'.format(cont),
             index=None, compression='gzip')
    
    cont += 1

implausibilidade = pd.DataFrame()

for f in glob.glob('SIM_dataset/resultados/Implausibilidade_p*.csv'):
    df = pd.read_csv(f, compression='gzip')
    implausibilidade = pd.concat([implausibilidade, df], axis=0)

implausibilidade.fillna(0, inplace=True)
implausibilidade = implausibilidade[~implausibilidade.VARIAVEL.isin(['contador','NOVO'])]
implausibilidade.to_csv('SIM_Implausibilidade_v2.csv', index=None, compression='gzip')

# gera regras

regras = {}
regras["IDADE"] = "Se campo IDADE for menor que 0 ou maior que 120"
regras["IDADEMAE"] = "Se campo IDADEMAE for menor que 0 ou maior que 120"
regras["QTDFILVIVO"] = "Se campo QTDFILVIVO for menor que 0 ou maior que 70"
regras["QTDFILMORT"] = "Se campo QTDFILMORT for menor que 0 ou maior que 70"
regras["PESO"] = "Se campo PESO for menor que 0 ou maior que 11000"

for k in regras_gerais.keys():
    if k not in regras.keys():
        regras[k] = "Se o campo " + k + "não for preenchido com " + str(regras_gerais[k])
    
with open('SIM_Implausibilidade_Regras.json', 'w') as fp:
    json.dump(regras, fp,  indent=4)
    
## inconsistencia ######################################################################################

regras = {}
cont = 0

def convert_date(col):
    
    col = col.fillna(0)
    data_string = col.apply(int).apply(str)
    y = data_string.str[-4:]
    m = data_string.str[-6:-4]
    d = data_string.str[:-6]
    return y.str.cat(m.str.cat(d.str.zfill(2)))

# inconsistencias
for f in glob.glob('SIM_dataset/*.csv'):
    
    df = pd.read_csv(f)
    ano = df['DTOBITO'] % 10000
    codmun = df['CODMUNOCOR']
    
    aux_cols = [
        'DTOBITO',
        'DTNASC',
        'SEXO',
        'OBITOPARTO',
        'OBITOGRAV',
        'OBITOPUERP',
        'LOCOCOR',
        'FONTE'
    ]
    
    aux = df[aux_cols]
            
    # DTOBITO menor que DTNASC
    regras['DTOBITO_e_DTNASC'] = "Se a data de óbito for menor que a data de nascimento"
    aux['DTOBITO'] = convert_date(aux['DTOBITO'])
    aux['DTNASC'] = convert_date(aux['DTNASC'])
        
    aux['DTOBITO_e_DTNASC_INCONSISTENTES'] = (aux['DTOBITO'] < aux['DTNASC'])
        
    # se SEXO estiver como M ou I e os campos OBITOPARTO, OBITOGRAV, OBITOPUERP estiverem preenchidos
    regras['SEXO_e_OBITO'] = "Se SEXO for diferente de 'M','I' e os campos relativos a óbitos em mulheres estiverem preenchidos"

    obito_preenchido = (~aux['OBITOPARTO'].isna()) | (~aux['OBITOGRAV'].isna()) | (~aux['OBITOPUERP'].isna())
    aux['SEXO_e_OBITO_INCONSISTENTES'] = (aux['SEXO'].isin(['M','I'])) & (obito_preenchido)
    
    # Se OBITOPARTO preenchido como 3 e OBITOPUERP estiver como 3 ou OBITOGRAV estiver como 1; 
    # Se OBITOPARTO preenchido como 1 ou 2 e OBITOGRAV estiver como 2 ou OBITOPUERP estiver como 1 ou 2; 
    # Se OBITOPARTO preenchido como 9, OBITOGRAV estiver como 1 ou 2 ou OBITOPUERP estiver como 1,2 ou 3
    regras['OBITO_PUERPERIO_GRAVIDEZ'] = "Se OBITOPARTO e OBITOPUERP estiver como 3 ou OBITOGRAV estiver como 1;"
    regras['OBITO_PUERPERIO_GRAVIDEZ'] += "Se OBITOPARTO estiver como 1 ou 2 e OBITOGRAV estiver como 2, ou OBITOPUERP estiver como 1 ou 2;"
    regras['OBITO_PUERPERIO_GRAVIDEZ'] += "Se OBITOPARTO estiver como 9 e OBITOGRAV estiver como 1 ou 2, ou OBITOPUERP estiver como 1, 2 ou 3"

    parte_1 = (aux['OBITOPARTO'] == 3) & ((aux['OBITOPARTO'] == 3) | (aux['OBITOGRAV'] == 1))
    parte_2 = (aux['OBITOPARTO'].isin([1,2])) & ((aux['OBITOGRAV'] == 2) | (aux['OBITOPUERP'].isin([1,2])))
    parte_3 = (aux['OBITOPARTO'] == 9) & ((aux['OBITOGRAV'].isin([1,2])) | (aux['OBITOPUERP'].isin([1,2,3])))
    aux['OBITO_PUERPERIO_GRAVIDEZ_INCONSISTENTES'] = (parte_1) | (parte_2) | parte_3
    
    # Preechido como 1 e o item Morte durante o puerperio também for preenchido como 1,2 ou 9
    regras['OBITOGRAV_e_OBITOPUERP'] = "Se OBITOGRAV estiver como 1 e OBITOPUERP estiver como 1, 2 ou 9"

    aux['OBITOGRAV_e_OBITOPUERP_INCONSISTENTES'] = (aux['OBITOGRAV'] == 1) & (aux['OBITOPUERP'].isin([1,2,3]))
    
    # Preenchido como 1 ou 2 e o item morte durante a gravidez estiver preenchido como 1 ou 9
    regras['OBITOPUERP_e_OBITOGRAV'] = "Se OBITOGRAV estiver como 1 ou 2 e OBITOGRAV estiver como 1 ou 9"
    
    aux['OBITOPUERP_e_OBITOGRAV_INCONSISTENTES'] = (aux['OBITOGRAV'].isin([1,2])) & (aux['OBITOGRAV'].isin([1,9]))
    
    # Se FONTE diferente de 2 e LOCOCOR for igual a 1
    regras['FONTE_E_LOCOCOR'] = "Se FONTE estiver diferente de 2 e LOCOCOR estiver como 1"

    aux['FONTE_E_LOCOCOR_INCONSISTENTES'] = (aux['FONTE'] != 2) & (aux['LOCOCOR'] == 1)
    
    aux_cols = []
    for c in aux.columns:
        if 'INCONSISTENTES' in c:
            aux_cols.append(c)
            
    aux = aux[aux_cols]
    
    aux['ANO'] = ano
    aux['CODMUNOCOR'] = codmun

    
    df_inconsistentes = aux
    
    df_inconsistentes.fillna(0, inplace=True)
    
    df_inconsistentes = df_inconsistentes.groupby(['ANO','CODMUNOCOR']).sum().reset_index().melt(id_vars=['ANO','CODMUNOCOR'])
    df_inconsistentes.columns = ['ANO','CODMUNOCOR','VARIAVEL','INCONSISTENTES']    

    
    df['ANO'] = ano
    df['CODMUNOCOR'] = codmun
    
    df_totais = df[['ANO','CODMUNOCOR']]
    df_totais['TOTAIS'] = 1

    df_totais = df_totais.groupby(['ANO','CODMUNOCOR'])['TOTAIS'].sum().reset_index()
    df_totais.columns = ['ANO','CODMUNOCOR','TOTAIS']
        
    df_totais.set_index(['ANO','CODMUNOCOR'], inplace=True)
    df_inconsistentes.set_index(['ANO','CODMUNOCOR'], inplace=True)
        
    x = df_totais.join([df_inconsistentes], how='left')
    x = x.reset_index()
    
    x = x[['ANO','CODMUNOCOR','VARIAVEL','INCONSISTENTES','TOTAIS']]
    
    x = x.fillna(0)
    
    x.to_csv('SIM_dataset/resultados/Inconsistencia_p{}.csv'.format(cont),
             index=None, compression='gzip')
    
    cont += 1
inconsistencias = pd.DataFrame()

for f in glob.glob('SIM_dataset/resultados/Inconsistencia_p*.csv'):
    df = pd.read_csv(f, compression='gzip')
    inconsistencias = pd.concat([inconsistencias, df], axis=0)

inconsistencias.fillna(0, inplace=True)
inconsistencias = inconsistencias[~inconsistencias.VARIAVEL.isin(['contador','NOVO'])]
inconsistencias.to_csv('SIM_Inconsistencia_v2.csv', index=None, compression='gzip')

# gera regras

   
with open('SIM_Inconsistencia_Regras.json', 'w') as fp:
    json.dump(regras, fp,  indent=4)

```

### Análise 
 



